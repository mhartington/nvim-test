"use strict";
// Plugin decorator
Object.defineProperty(exports, "__esModule", { value: true });
const properties_1 = require("./properties");
function wrapper(cls, options) {
    return class WrapperClass extends cls {
        constructor(plugin) {
            super(plugin.nvim, plugin);
            this.setApi(plugin.nvim);
            if (options) {
                plugin.setOptions(options);
            }
            // Search for decorated methods
            Object.getOwnPropertyNames(cls.prototype).forEach(methodName => {
                const method = cls.prototype[methodName];
                if (method && method[properties_1.NVIM_SPEC]) {
                    const spec = method[properties_1.NVIM_SPEC];
                    switch (spec.type) {
                        case 'autocmd':
                            const autoCmdOpts = {
                                pattern: spec.opts.pattern,
                                sync: spec.sync,
                            };
                            if (typeof spec.opts.eval !== 'undefined') {
                                autoCmdOpts.eval = spec.opts.eval;
                            }
                            plugin.registerAutocmd(spec.name, [this, method], autoCmdOpts);
                            break;
                        case 'command':
                            const cmdOpts = {
                                sync: spec.sync,
                            };
                            if (typeof spec.opts.range !== 'undefined') {
                                cmdOpts.range = spec.opts.range;
                            }
                            if (typeof spec.opts.nargs !== 'undefined') {
                                cmdOpts.nargs = spec.opts.nargs;
                            }
                            plugin.registerCommand(spec.name, [this, method], cmdOpts);
                            break;
                        case 'function':
                            const funcOpts = {
                                sync: spec.sync,
                            };
                            if (typeof spec.opts.range !== 'undefined') {
                                funcOpts.range = spec.opts.range;
                            }
                            if (typeof spec.opts.eval !== 'undefined') {
                                funcOpts.eval = spec.opts.eval;
                            }
                            plugin.registerFunction(spec.name, [this, method], funcOpts);
                            break;
                        default:
                            break;
                    }
                }
            });
        }
        setApi(nvim) {
            this.nvim = nvim;
        }
    };
}
// eslint-disable-next-line import/export
function Plugin(outter) {
    /**
     * Decorator should support
     *
     * @Plugin(opts)
     * class TestPlug {}
     *
     * and
     *
     * @PluginA
     * class TestPlug {}
     *
     *and
     *
     * Plugin(opts)(TestPlugin)
     *
     * or
     *
     * Plugin(TestPlugin)
     */
    return typeof outter !== 'function'
        ? (cls) => wrapper(cls, outter)
        : wrapper(outter);
}
exports.Plugin = Plugin;
